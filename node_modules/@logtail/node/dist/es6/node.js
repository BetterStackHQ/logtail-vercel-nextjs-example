import fetch from "cross-fetch";
import { encode } from "@msgpack/msgpack";
import { Base } from "@logtail/core";
import { getStackContext } from "./context";
export class Node extends Base {
    constructor(sourceToken, options) {
        super(sourceToken, options);
        // Sync function
        const sync = async (logs) => {
            const res = await fetch(this._options.endpoint, {
                method: "POST",
                headers: {
                    "Content-Type": "application/msgpack",
                    Authorization: `Bearer ${this._sourceToken}`,
                    "User-Agent": "logtail-js(node)"
                },
                body: this.encodeAsMsgpack(logs)
            });
            if (res.ok) {
                return logs;
            }
            throw new Error(res.statusText);
        };
        // Set the throttled sync function
        this.setSync(sync);
    }
    /**
     * Override `Base` log to enable Node.js streaming
     *
     * @param message: string - Log message
     * @param level (LogLevel) - Level to log at (debug|info|warn|error)
     * @param log: (Partial<ILogtailLog>) - Initial log (optional)
     * @returns Promise<ILogtailLog> after syncing
     */
    async log(message, level, context = {}) {
        // Process/sync the log, per `Base` logic
        context = Object.assign(Object.assign({}, getStackContext(this)), context);
        const processedLog = await super.log(message, level, context);
        // Push the processed log to the stream, for piping
        if (this._writeStream) {
            this._writeStream.write(JSON.stringify(processedLog) + "\n");
        }
        // Return the transformed log
        return processedLog;
    }
    /**
     * Pipe JSON stringified `ILogtailLog` to a stream after syncing
     *
     * @param stream - Writable|Duplex stream
     */
    pipe(stream) {
        this._writeStream = stream;
        return stream;
    }
    encodeAsMsgpack(logs) {
        const logsWithISODateFormat = logs.map((log) => (Object.assign(Object.assign({}, log), { dt: log.dt.toISOString() })));
        const encoded = encode(logsWithISODateFormat);
        const buffer = Buffer.from(encoded.buffer, encoded.byteOffset, encoded.byteLength);
        return buffer;
    }
}
//# sourceMappingURL=node.js.map