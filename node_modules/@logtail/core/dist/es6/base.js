import { LogLevel } from "@logtail/types";
import { makeBatch, makeThrottle } from "@logtail/tools";
// Set default options for Logtail
const defaultOptions = {
    // Default sync endpoint (protocol + domain)
    endpoint: "https://in.logtail.com",
    // Maximum number of logs to sync in a single request to Logtail.com
    batchSize: 1000,
    // Max interval (in milliseconds) before a batch of logs proceeds to syncing
    batchInterval: 1000,
    // Maximum number of sync requests to make concurrently
    syncMax: 5,
    // If true, errors/failed logs should be ignored
    ignoreExceptions: false
};
/**
 * Logtail core class for logging to the Logtail.com service
 */
class Logtail {
    /* CONSTRUCTOR */
    /**
     * Initializes a new Logtail instance
     *
     * @param sourceToken: string - Private source token for logging to Logtail.com
     * @param options?: ILogtailOptions - Optionally specify Logtail options
     */
    constructor(sourceToken, options) {
        // Middleware
        this._middleware = [];
        // Number of logs logged
        this._countLogged = 0;
        // Number of logs successfully synced with Logtail
        this._countSynced = 0;
        // First, check we have a valid source token
        if (typeof sourceToken !== "string" || sourceToken === "") {
            throw new Error("Logtail source token missing");
        }
        // Store the source token, to use for syncing with Logtail.com
        this._sourceToken = sourceToken;
        // Merge default and user options
        this._options = Object.assign(Object.assign({}, defaultOptions), options);
        // Create a throttler, for sync operations
        const throttle = makeThrottle(this._options.syncMax);
        // Sync after throttling
        const throttler = throttle((logs) => {
            return this._sync(logs);
        });
        // Create a batcher, for aggregating logs by buffer size/interval
        const batcher = makeBatch(this._options.batchSize, this._options.batchInterval);
        this._batch = batcher((logs) => {
            return throttler(logs);
        });
    }
    /* PRIVATE METHODS */
    getContextFromError(e) {
        return {
            stack: e.stack
        };
    }
    /* PUBLIC METHODS */
    /**
     * Number of entries logged
     *
     * @returns number
     */
    get logged() {
        return this._countLogged;
    }
    /**
     * Number of log entries synced with Logtail.com
     *
     * @returns number
     */
    get synced() {
        return this._countSynced;
    }
    /**
     * Log an entry, to be synced with Logtail.com
     *
     * @param message: string - Log message
     * @param level (LogLevel) - Level to log at (debug|info|warn|error)
     * @param context: (Context) - Context (optional)
     * @returns Promise<ILogtailLog> after syncing
     */
    async log(message, level = LogLevel.Info, context = {}) {
        // Check that we have a sync function
        if (typeof this._sync !== "function") {
            throw new Error("No Logtail logger sync function provided");
        }
        // Increment log count
        this._countLogged++;
        // Start building the log message
        let log = Object.assign({ 
            // Implicit date timestamp
            dt: new Date(), 
            // Explicit level
            level }, context);
        // Determine the type of message...
        // Is this an error?
        if (message instanceof Error) {
            log = Object.assign(Object.assign(Object.assign({}, log), this.getContextFromError(message)), { 
                // Add error message
                message: message.message });
        }
        else {
            log = Object.assign(Object.assign({}, log), { 
                // Add string message
                message });
        }
        // Pass the log through the middleware pipeline
        const transformedLog = await this._middleware.reduceRight((fn, pipedLog) => fn.then(pipedLog), Promise.resolve(log));
        try {
            // Push the log through the batcher, and sync
            await this._batch(transformedLog);
            // Increment sync count
            this._countSynced++;
        }
        catch (e) {
            // Catch any errors - re-throw if `ignoreExceptions` == false
            if (!this._options.ignoreExceptions) {
                throw e;
            }
        }
        // Return the resulting log
        return transformedLog;
    }
    /**
     *
     * Debug level log, to be synced with Logtail.com
     *
     * @param message: string - Log message
     * @param context: (Pick<ILogtailLog, "context">) - Context (optional)
     * @returns Promise<ILogtailLog> after syncing
     */
    async debug(message, context = {}) {
        return this.log(message, LogLevel.Debug, context);
    }
    /**
     *
     * Info level log, to be synced with Logtail.com
     *
     * @param message: string - Log message
     * @param context: (Pick<ILogtailLog, "context">) - Context (optional)
     * @returns Promise<ILogtailLog> after syncing
     */
    async info(message, context = {}) {
        return this.log(message, LogLevel.Info, context);
    }
    /**
     *
     * Warning level log, to be synced with Logtail.com
     *
     * @param message: string - Log message
     * @param context: (Pick<ILogtailLog, "context">) - Context (optional)
     * @returns Promise<ILogtailLog> after syncing
     */
    async warn(message, context = {}) {
        return this.log(message, LogLevel.Warn, context);
    }
    /**
     *
     * Warning level log, to be synced with Logtail.com
     *
     * @param message: string - Log message
     * @param context: (Pick<ILogtailLog, "context">) - Context (optional)
     * @returns Promise<ILogtailLog> after syncing
     */
    async error(message, context = {}) {
        return this.log(message, LogLevel.Error, context);
    }
    /**
     * Sets the sync method - i.e. the final step in the pipeline to get logs
     * over to Logtail.com
     *
     * @param fn - Pipeline function to use as sync method
     */
    setSync(fn) {
        this._sync = fn;
    }
    /**
     * Add a middleware function to the logging pipeline
     *
     * @param fn - Function to add to the log pipeline
     * @returns void
     */
    use(fn) {
        this._middleware.push(fn);
    }
    /**
     * Remove a function from the pipeline
     *
     * @param fn - Pipeline function
     * @returns void
     */
    remove(fn) {
        this._middleware = this._middleware.filter(p => p !== fn);
    }
}
// noinspection JSUnusedGlobalSymbols
export default Logtail;
//# sourceMappingURL=base.js.map